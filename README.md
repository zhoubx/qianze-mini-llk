结论：用共享模块 require 并不能做到“跨云函数全局只有一个连接池”。它只能保证“同一实例进程内只创建一次并复用”，无法跨实例、跨云函数包、跨进程共享。

- 为什么不行
  - require 缓存是“进程内”的；云函数会按负载启动多个实例，每个实例都是一个独立进程，各自都会初始化一次连接池。
  - 不同云函数是不同代码包、不同进程，即使引用同一路径的共享模块，也只是在各自进程里形成“进程内单例”，不是全局单例。

- 全局统一管理连接数的可选方案
  - 架构集中化：把所有 DB 访问集中到一个后端服务（或一个“网关云函数”），其他云函数通过内部调用/HTTP 访问该服务，由它维护唯一的连接池。
    - 限制：该“网关”一旦扩容，还是会产生多个实例，每个实例有自己的池；要结合平台能力（如最大实例数/并发）控制扩容，才能接近“少量池”的目标。
  - 使用数据库连接代理：MySQL Router/ProxySQL 等代理层在数据库前统一复用与限制连接；你的云函数池设置较小，通过代理做汇聚与限流。
  - 平台托管连接：采用云开发 SDK（如 app.rdb()）或平台提供的 Data API，由平台侧做连接复用与限流。
  - 配置治理：接受“每实例一池”的现实，通过统一的共享模块将 connectionLimit 设为小值（如 2–5）、设置查询超时与应用层背压，控制总连接占用。

- 你的项目的实际影响（举例）
  - 假设有 10 个云函数，每个函数在峰值时扩容到 3 个实例；每实例池大小为 8，则总连接上限≈10×3×8=240。  
    - 通过共享模块统一把 connectionLimit 降到 3，总上限≈10×3×3=90；同时设置查询超时与队列等待，避免瞬时把数据库打满。
  - getLeaderboard 高并发刷新时，平台会分散到多个实例；每个实例复用自己的单例池。无法让所有请求都走同一个池，除非你把所有排行榜请求都路由到一个“固定实例”的服务（通常不现实，且会成为瓶颈）。

- 推荐做法
  - 统一封装共享模块（如 cloudfunctions/lib/mysql-pool），实现“进程内单例、跨模块复用”，在所有云函数内保持一致的连接参数与事务策略。
  - 严控每实例池大小（2–5），开启 waitForConnections，让多余请求排队；为查询设置超时（3–5s），防止慢查询长期占用连接。
  - 优化查询与索引，避免长事务；写路径用显式事务与行级锁，提供死锁重试。
  - 若平台支持，限制最大实例数或并发，配合小池实现“总连接可控”。没有平台级控制时，通过降低池大小与拆分读写来间接控制。
  - 对流量极低的云函数，考虑不使用池而是短连接（createConnection），进一步减少常驻连接占用；对高频函数保留小池。

如果你愿意，我可以把这些治理策略统一到一个共享模块，并把现有云函数切换为引用它（保留 mysql2），然后提供每个文件的修改预览；同时给出一个“网关式调用”的参考实现，帮助你集中管理热点查询。


==============================================



**是否混用可行**
- 可行，但需遵循边界：同一个请求路径内不要跨两种连接完成同一事务；一次业务操作只选一种连接方式，避免跨连接的原子性与锁失效。
- 风险与成本：两套错误处理、重试策略、日志与指标需要各自维护；不同默认设置（SQL_MODE、时区、隔离级别）可能导致行为差异。
- 一致性建议：写操作（有强事务/锁需求）统一用 mysql2；读操作（复杂聚合/窗口/多表关联）也倾向 mysql2；简单 CRUD 或对并发敏感的轻量查询可以用 app.rdb()。
- 配置管理：确保两套连接指向同一数据库实例，权限最小化；在代码层划清“读模块/写模块”，不要在同一函数里混用。

**云开发 SDK 的连接与事务**
- 连接池耗尽：app.rdb()通常通过平台侧的网关/代理复用连接，不在你的函数进程里维护本地池；因此“本地池耗尽”的问题基本不存在。但后端数据库连接上限仍然存在，极端高并发下会触发平台限流或等待。
- 连接超时：仍可能出现（网络、后端负载、长查询），SDK会以错误返回；你需要设置合理的超时、重试与降级策略。
- 事务管理：部分 SDK提供事务接口，但能力通常不如直接 SQL 灵活（如行级锁、锁超时、隔离级别调优）。若需要精细的事务/锁控制（SELECT … FOR UPDATE、死锁重试、幂等保障），建议使用 mysql2。
- 监控与调优：使用 SDK 也要监控慢查询、并发与错误码；尽量把复杂逻辑下推到 SQL，避免在代码层做大批量去重/聚合导致长时间持有资源。

**窗口函数与分组对比**
- 版本：窗口函数是 MySQL 8 引入的新特性（ROW_NUMBER、RANK、SUM OVER、PARTITION BY/ORDER BY 等）。
- 与 GROUP BY 的差异：
  - 行保留 vs 行折叠：窗口函数在不折叠行的前提下计算分区内的排名/累计/百分比；GROUP BY 会把分组结果聚合成更少的行。
  - Top-N/去重场景：窗口函数用 ROW_NUMBER() PARTITION BY 实现“每个 openid 取第一条”更直观且可加入稳定的并列排序条件；GROUP BY 需派生表 + 回表 JOIN，遇到并列分数选择具体行更繁琐。
  - 复杂分析指标：窗口函数适合移动平均、累计值、百分位等分析型计算；GROUP BY 更适合单次聚合（COUNT、SUM、MAX）。
  - 性能与执行计划：窗口函数通常需要排序（ORDER BY），GROUP BY 也可能需要排序或哈希聚合；实际性能取决于索引、数据分布与执行计划。很多“每分区取第一条”的任务，窗口函数往往更简单且避免额外 JOIN。
- 排行榜示例优势：用窗口函数可以明确 tie-break（如 score DESC, created_at ASC），保证结果可重复；GROUP BY + JOIN 在并列时需额外条件，否则可能随机选中某条。

**实践建议**
- 读写分层：把复杂读（排行榜、统计报表）和强事务写（成绩 PK/发券）都放在 mysql2；简单、非关键的查询可以使用 app.rdb() 以减少自管连接的开销。
- 单例池与限流：mysql2 在模块级维护单例 Pool，合理设置 connectionLimit（如 3–10），避免每个函数实例开大池导致总连接爆炸；配合应用层限流。
- 事务与锁：写路径用显式事务（BEGIN/COMMIT/ROLLBACK）与 SELECT … FOR UPDATE，提供死锁重试与幂等保障。
- 索引与稳定排序：为排行榜建立覆盖索引并定义稳定排序（score DESC, created_at ASC）；确保执行计划走索引而不是全表排序。

如果你决定混用，我可以帮你梳理各云函数的“连接方式矩阵”，明确每个函数用哪一种连接，并补齐连接池与事务的最佳实践。